using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using SplayCode.Controls;
using System.Windows.Media;
using SplayCode.Data;
using System.Windows.Input;

namespace SplayCode
{
    /// <summary>
    /// Represents a file block, consisting of a frame and editor, within the virtual space.
    /// </summary>
    public partial class BlockControl : UserControl
    {
        private EditorControl editor;
        public EditorControl Editor
        {
            get { return editor; }
        }

        public string Label
        {
            get { return (string)label.Content; }
        }
        public string DocumentPath
        {
            get { return editor.FilePath; }
        }
        private int blockId;
        public int BlockId
        {
            get { return blockId; }
        }

        private bool duringResize = false;

        // Default and minimum sizes for a block
        public static readonly double MINIMUM_BLOCK_HEIGHT = 300;
        public static readonly double MINIMUM_BLOCK_WIDTH = 300;
        public static readonly double DEFAULT_BLOCK_HEIGHT = 600;
        public static readonly double DEFAULT_BLOCK_WIDTH = 600;

        // Default colours
        public static readonly Color HIGHLIGHT_COLOR = Color.FromArgb(0xFF, 0xFF, 0xEF, 0x9F);
        public static readonly Color NON_HIGHLIGHT_COLOR = Color.FromArgb(0xFF, 0xC2, 0xC3, 0xC9);
        public static readonly Color SELECTION_BORDER_COLOR = Color.FromArgb(0xFF, 0x74, 0x86, 0xA6);

        public BlockControl(string label, string documentPath, int id)
        {
            InitializeComponent();
            editor = new EditorControl(documentPath);

            contentSpace.Children.Add(editor);
            blockId = id;
            this.label.Content = label;

            this.GotMouseCapture += BlockControl_GotFocus;
            this.GotTouchCapture += BlockControl_GotFocus;
            this.GotKeyboardFocus += BlockControl_GotKeyboardFocus;
            this.MouseEnter += ShowOverlayBar;
            this.MouseLeave += HideOverlayBar;

            MinHeight = MINIMUM_BLOCK_HEIGHT;
            MinWidth = MINIMUM_BLOCK_WIDTH;
            Height = DEFAULT_BLOCK_HEIGHT;
            Width = DEFAULT_BLOCK_WIDTH;

        }

        /// <summary>
        /// Event handler for when the block gets mouse or touch focus.
        /// </summary>
        private void BlockControl_GotFocus(object sender, RoutedEventArgs e)
        {
            if ((e.OriginalSource != closeButton) && (e.OriginalSource != closeIcon))
            {
                BlockManager.Instance.SetActiveBlock(this);
            }
        }

        /// <summary>
        /// Event handler for when the block gets keyboard focus.
        /// </summary>
        private void BlockControl_GotKeyboardFocus(object sender, RoutedEventArgs e)
        {
            // sets the block active only if the focus is generated by the user putting the cursor on it
            if (IsMouseOver)
            {
                BlockManager.Instance.SetActiveBlock(this);
            }
            // removes the unwanted focus caused by external switching events
            if (!Equals(BlockManager.Instance.ActiveBlock))
            {
                Keyboard.ClearFocus();
            }
        }

        /// <summary>
        /// Shows the enlarged title bar on the frame when zoom level is lower than 90%.
        /// </summary>
        private void ShowOverlayBar(object sender, MouseEventArgs e)
        {
            if (!duringResize && VirtualSpaceControl.Instance.ZoomLevel <= 0.9)
            {
                ScaleTransform scaleTransform = new ScaleTransform(1.0 / VirtualSpaceControl.Instance.ZoomLevel,
                    1.0 / VirtualSpaceControl.Instance.ZoomLevel);
                labelBar.RenderTransform = scaleTransform;
                Thickness t = labelBar.Margin;
                double edgeWidth = chrome.BorderThickness.Left;
                t.Left = t.Left + ((Width - Width * VirtualSpaceControl.Instance.ZoomLevel) / 2) -
                    edgeWidth;
                t.Right = t.Right + ((Width - Width * VirtualSpaceControl.Instance.ZoomLevel) / 2) -
                    edgeWidth;
                if ((Width - t.Left - t.Right) < 250)
                {
                    t.Left = (Width - 250) / 2;
                    t.Right = (Width - 250) / 2;
                }
                labelBar.Margin = t;
            }
        }

        /// <summary>
        /// Hides the enlarged title bar.
        /// </summary>
        private void HideOverlayBar(object sender, MouseEventArgs e)
        {
            ScaleTransform scaleTransform1 = new ScaleTransform(1.0, 1.0);
            labelBar.RenderTransform = scaleTransform1;
            Thickness t = labelBar.Margin;
            t.Left = 0;
            t.Right = 0;            
            labelBar.Margin = t;
        }

        /// <summary>
        /// Toggles frame highlight.
        /// </summary>
        public void SetHighlight(bool highlightOn)
        {
            if (highlightOn)
            {
                chrome.BorderBrush = new SolidColorBrush(HIGHLIGHT_COLOR);
                label.Background = new SolidColorBrush(HIGHLIGHT_COLOR);
            }
            else
            {
                chrome.BorderBrush = new SolidColorBrush(NON_HIGHLIGHT_COLOR);
                label.Background = new SolidColorBrush(NON_HIGHLIGHT_COLOR);
            }            
        }

        /// <summary>
        /// Positions this block in the virtual space by the Top and Left of the given Thickness.
        /// </summary>
        public void Position(Thickness m)
        {
            this.Margin = m;
            Thickness t = new Thickness();
            t.Left = m.Left - VirtualSpaceControl.Instance.ScrollView.HorizontalOffset;
            t.Top = m.Top - VirtualSpaceControl.Instance.ScrollView.VerticalOffset;
            RefreshVirtualSpaceSize();
        }

        /// <summary>
        /// Shifts the position of this block by the given delta values.
        /// </summary>
        public void Reposition(double xDelta, double yDelta)
        {
            Thickness t = this.Margin;
            t.Left = t.Left + xDelta;
            t.Top = t.Top + yDelta;
            this.Margin = t;
            RefreshVirtualSpaceSize();
        }

        /// <summary>
        /// Handler for close button.
        /// </summary>
        private void closeButton_Click(object sender, RoutedEventArgs e)
        {
            UndoManager.Instance.SaveState();
            BlockManager.Instance.RemoveBlock(this);
        }

        /// <summary>
        /// Handler for maximize button.
        /// </summary>
        private void maximizeButton_Click(object sender, RoutedEventArgs e)
        {
            VirtualSpaceControl.Instance.EnterEditorView(this);
        }

        /// <summary>
        /// Handler for drag start, saves the block states before movement.
        /// </summary>
        void onDragStart(object sender, DragStartedEventArgs e)
        {
            UndoManager.Instance.SaveState();
        }

        /// <summary>
        /// Handler for during drag.
        /// </summary>
        void onDragDelta(object sender, DragDeltaEventArgs e)
        {
            BlockManager.Instance.ShiftBlock(this, e.HorizontalChange, e.VerticalChange); 
        }

        /// <summary>
        /// Handler for all resize events.
        /// </summary>
        void onResizeStart(object sender, DragStartedEventArgs e)
        {
            duringResize = true;
            HideOverlayBar(this, null);
            UndoManager.Instance.SaveState();
        }

        void onResizeComplete(object sender, DragCompletedEventArgs e)
        {
            duringResize = false;
            ShowOverlayBar(this, null);
        }

        void onLeftResizeDelta(object sender, DragDeltaEventArgs e)
        {
            if (Width - e.HorizontalChange >= this.MinWidth)
            {
                // Adjust block size
                Width = Width - e.HorizontalChange;
                Reposition(e.HorizontalChange, 0);
            }
        }

        void onRightResizeDelta(object sender, DragDeltaEventArgs e)
        {
            if (Width + e.HorizontalChange >= this.MinWidth)
            {
                // Adjust block size
                Width = Width + e.HorizontalChange;
            }
        }

        void onBottomResizeDelta(object sender, DragDeltaEventArgs e)
        {
            if (Height + e.VerticalChange >= this.MinHeight)
            {
                // Adjust block size
                Height = Height + e.VerticalChange;
            }
        }

        void onBottomRightResizeDelta(object sender, DragDeltaEventArgs e)
        {
            onRightResizeDelta(sender, e);
            onBottomResizeDelta(sender, e);
        }

        void onBottomLeftResizeDelta(object sender, DragDeltaEventArgs e)
        {
            onLeftResizeDelta(sender, e);
            onBottomResizeDelta(sender, e);
        }

        void RefreshVirtualSpaceSize()
        {
            VirtualSpaceControl.Instance.ExpandToSize(Margin.Left + Width, Margin.Top + Height);
        }

        void onDoubleClick(object sender, RoutedEventArgs e)
        {
            VirtualSpaceControl.Instance.CenterViewOn(this);
        }

        /// <summary>
        /// Turn the selection border on/off.
        /// </summary>
        public void ToggleSelectionBorder(bool borderOn)
        {
            if (borderOn)
            {
                BorderBrush = new SolidColorBrush(SELECTION_BORDER_COLOR);
            }
            else
            {
                BorderBrush = Brushes.Transparent;
            }
        }

        private void selectionCheckBox_Checked(object sender, RoutedEventArgs e)
        {
            ToggleSelectionBorder(true);
            BlockManager.Instance.RegisterBlockSelection(this);
        }

        private void selectionCheckBox_Unchecked(object sender, RoutedEventArgs e)
        {
            ToggleSelectionBorder(false);
            BlockManager.Instance.RemoveBlockSelection(this);
        }
    }
}
